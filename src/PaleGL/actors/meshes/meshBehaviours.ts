import { Actor, ActorStartArgs, ActorUpdateArgs } from '@/PaleGL/actors/actor.ts';
import { startActorBehaviourBase, UpdateActorFunc } from '@/PaleGL/actors/actorBehaviours.ts';
import { Camera } from '@/PaleGL/actors/cameras/camera.ts';
import { Mesh } from '@/PaleGL/actors/meshes/mesh.ts';
import {
    updateObjectSpaceRaymarchDepthMaterial,
    updateObjectSpaceRaymarchMesh,
    updateObjectSpaceRaymarchMeshMaterial,
} from '@/PaleGL/actors/meshes/objectSpaceRaymarchMeshBehaviour.ts';
import { setSizeScreenSpaceRaymarchMesh } from '@/PaleGL/actors/meshes/screenSpaceRaymarchMesh.ts';
import { startSkinnedMesh, updateSkinnedMesh } from '@/PaleGL/actors/meshes/skinnedMesh.ts';
import { Skybox } from '@/PaleGL/actors/meshes/skybox.ts';
import { ActorType, DepthFuncTypes, MeshType, MeshTypes } from '@/PaleGL/constants.ts';
import { defaultDepthFragmentShader } from '@/PaleGL/core/buildShader.ts';
import { Gpu } from '@/PaleGL/core/gpu.ts';
import { deleteProgram } from '@/PaleGL/core/shader.ts';
import { UniformValue } from '@/PaleGL/core/uniforms.ts';
import { getGeometryAttributeDescriptors } from '@/PaleGL/geometries/geometryBehaviours.ts';
import {
    createMaterial,
    isCompiledMaterialShader,
    Material,
    MaterialArgs,
    setMaterialUniformValue,
    startMaterial,
} from '@/PaleGL/materials/material.ts';
import { updateMaterial } from '@/PaleGL/materials/materialBehaviours.ts';

// start actor -------------------------------------------------------

// export const startMesh: StartActorFunc = (actor: Actor, args: ActorStartArgs) => {
export function startMeshBehaviourBase(mesh: Mesh, args: ActorStartArgs) {
    startActorBehaviourBase(mesh, args);

    const { gpu } = args;

    // for debug
    // console.log(`[startMeshBehaviourBase] mesh: ${mesh.name}, materials length: ${mesh.materials.length}`);

    // 未コンパイルであればコンパイルする
    mesh.materials.forEach((material) => {
        // for debug
        // console.log(`[Mesh.start] material name: ${material.getName()}, isCompiledShader: ${material.isCompiledShader()}`);
        if (!isCompiledMaterialShader(material)) {
            startMaterial(material, {
                gpu,
                attributeDescriptors: getGeometryAttributeDescriptors(mesh.geometry),
            });
            // for debug
            // console.log(`[Mesh.start] material`, material, material.getShader());
        }
    });

    mesh.materials.forEach((material, i) => {
        if (!mesh.depthMaterials[i] && mesh.autoGenerateDepthMaterial) {
            // for debug
            // console.log(this.material, this.materials)
            // TODO: depth material から clone した方がいい気がする
            mesh.depthMaterials[i] = createMaterial({
                name: `${material.name}/depth`,
                vertexShader: material.rawVertexShader!, // TODO: rawじゃだめじゃん？
                fragmentShader: material.depthFragmentShader || defaultDepthFragmentShader(),
                fragmentShaderModifiers: material.depthFragmentShaderModifiers, // TODO: ややこしいけど、depthのときはfragmentShaderModifiersを使う
                uniforms: material.depthUniforms.data, // TODO: deepcopyした方がよい？
                faceSide: material.faceSide,
                depthTest: true,
                depthWrite: true,
                depthFuncType: DepthFuncTypes.Lequal,
                alphaTest: material.alphaTest,
                skipDepthPrePass: material.skipDepthPrePass,

                // TODO: 手動でいろいろ追加しなきゃなのが面倒
                isInstancing: material.isInstancing,
                useInstanceLookDirection: material.useInstanceLookDirection,
                useVertexColor: material.useVertexColor,

                uniformBlockNames: material.uniformBlockNames, // TODO: 外側からも追加して渡せるほうがいいかもしれない
                // depthFuncType: this.mainMaterial.depthFuncType
            });
        }
    });

    mesh.depthMaterials.forEach((material) => {
        if (!isCompiledMaterialShader(material)) {
            startMaterial(material, {
                gpu,
                attributeDescriptors: getGeometryAttributeDescriptors(mesh.geometry),
            });
            // for debug
            // console.log(`[Mesh.start] depth`, material, material.getShader());
        }
    });

    // for debug
    // console.log("main raw vertex", this.mainMaterial.rawVertexShader)
    // console.log("main raw fragment", this.mainMaterial.rawFragmentShader)
    // console.log("depth raw vertex", this.depthMaterial.rawVertexShader)
}

export const startMeshBehaviour: Partial<Record<MeshType, (mesh: Mesh, { gpu, scene }: ActorStartArgs) => void>> = {
    [MeshTypes.Skinned]: startSkinnedMesh,
};

export function startMesh(actor: Actor, args: ActorStartArgs) {
    const mesh = actor as Mesh;
    (startMeshBehaviour[mesh.meshType] ?? startMeshBehaviourBase)(mesh, args);
}

export function replaceAllMeshMaterials(mesh: Mesh, gpu: Gpu, args: MaterialArgs = {}) {
    // TODO: uniformsの中身を引き継いだ方がいいと思われる

    // shaderを削除しつつ、新しいmaterialを生成して差し替え
    mesh.materials.forEach((material, i) => {
        if (material.shader) {
            deleteProgram(gpu.gl, material.shader.glObject);
        }
        mesh.materials[i] = createMaterial({
            ...material.cachedArgs,
            ...args, // NOTE: 追加したい何かがあるときはここでoverride・
        });
    });
    // 差し替えたmaterialをコンパイル
    mesh.materials.forEach((material) => {
        if (!isCompiledMaterialShader(material)) {
            startMaterial(material, {
                gpu,
                attributeDescriptors: getGeometryAttributeDescriptors(mesh.geometry),
            });
        }
    });

    // depthのshaderも同様に、削除してから新しいマテリアルに差し替え
    mesh.depthMaterials.forEach((material, i) => {
        if (material.shader) {
            deleteProgram(gpu.gl, material.shader?.glObject);
        }
        mesh.depthMaterials[i] = createMaterial({
            ...material.cachedArgs,
        });
    });
    mesh.depthMaterials.forEach((material) => {
        if (!isCompiledMaterialShader(material)) {
            startMaterial(material, {
                gpu,
                attributeDescriptors: getGeometryAttributeDescriptors(mesh.geometry),
            });
        }
    });
}

// set size -------------------------------------------------------

export const setSizeMeshBehaviour: Partial<Record<ActorType, (mesh: Mesh, width: number, height: number) => void>> = {
    [MeshTypes.ScreenSpaceRaymarch]: setSizeScreenSpaceRaymarchMesh,
};

export function setSizeMesh(actor: Actor, width: number, height: number) {
    const mesh = actor as Mesh;
    setSizeMeshBehaviour[mesh.type]?.(mesh, width, height);
}

// update mesh ----------------------------------------------------------------

export const updateMeshBehaviour: Partial<Record<MeshType, UpdateActorFunc>> = {
    // [MeshTypes.Default]: () => console.log('updateMeshBehaviour: [MeshTypes.Default] is not implemented.'),
    [MeshTypes.Skinned]: updateSkinnedMesh,
    [MeshTypes.ObjectSpaceRaymarch]: updateObjectSpaceRaymarchMesh,
};

export function updateMesh(actor: Actor, args: ActorUpdateArgs) {
    const mesh = actor as Mesh;
    updateMeshBehaviour[mesh.meshType]?.(actor, args);
}

// update mesh material -------------------------------------------------------

// beforeRender({ gpu }: { gpu: Gpu }) {
//     super.beforeRender({ gpu });
//     // this.materials.forEach(material => material.updateUniforms({ gpu }));
//     // this.depthMaterial.updateUniforms({ gpu });
// }

export type UpdateMeshMaterial = (mesh: Mesh, args: { camera: Camera; skybox?: Skybox | null }) => void;

export const updateMeshMaterialBehaviour: Partial<Record<MeshType, UpdateMeshMaterial>> = {
    [MeshTypes.ObjectSpaceRaymarch]: updateObjectSpaceRaymarchMeshMaterial,
};

// update materials

// TODO: render前の方がよい気がする
export const updateMeshMaterial: UpdateMeshMaterial = (mesh, args) => {
    mesh.materials.forEach((material) => updateMaterial(material));
    updateMeshMaterialBehaviour[mesh.meshType]?.(mesh, args);
};

export const updateMeshDepthMaterialBehaviour: Partial<Record<MeshType, UpdateMeshMaterial>> = {
    [MeshTypes.ObjectSpaceRaymarch]: updateObjectSpaceRaymarchDepthMaterial,
};

export const updateMeshDepthMaterial: UpdateMeshMaterial = (mesh, args) => {
    mesh.depthMaterials.forEach((material) => updateMaterial(material));
    updateMeshDepthMaterialBehaviour[mesh.meshType]?.(mesh, args);
};

// -------------------------------------------------------

export const getMeshMaterial = (mesh: Mesh) => {
    if (hasMeshMaterials(mesh)) {
        // 複数マテリアルがあるかどうかを厳格に検知したい場合
        // console.warn('[getMeshMaterial] materials length > 1. material is head of materials.');
    }
    return getMeshMainMaterial(mesh);
};

export const setMeshMaterial = (mesh: Mesh, material: Material) => {
    mesh.materials = [material];
};

export const getMeshMainMaterial = (mesh: Mesh) => {
    return mesh.materials[0];
};

export const hasMeshMaterials = (mesh: Mesh) => {
    return mesh.materials.length > 1;
};

// utilites -------------------------------------------------------

export const setUniformValueToMeshPairMaterial = (mesh: Mesh, i: number, name: string, newValue: UniformValue) => {
    setMaterialUniformValue(mesh.materials[i], name, newValue);
    setMaterialUniformValue(mesh.depthMaterials[i], name, newValue);
};

export const setUniformValueToMeshMaterials = (mesh: Mesh, name: string, newValue: UniformValue, log?: boolean) => {
    mesh.materials.forEach((material) => setMaterialUniformValue(material, name, newValue, log));
};

export const setUniformValueToMeshDepthMaterials = (
    mesh: Mesh,
    name: string,
    newValue: UniformValue,
    log?: boolean
) => {
    mesh.depthMaterials.forEach((material) => setMaterialUniformValue(material, name, newValue, log));
};

export const setUniformValueToAllMeshMaterials = (mesh: Mesh, name: string, newValue: UniformValue, log?: boolean) => {
    mesh.materials.forEach((material) => setMaterialUniformValue(material, name, newValue, log));
    mesh.depthMaterials.forEach((material) => setMaterialUniformValue(material, name, newValue, log));
};

export const setCanRenderMeshMaterial = (mesh: Mesh, index: number, flag: boolean) => {
    mesh.materials[index].canRender = flag;
    mesh.depthMaterials[index].canRender = flag;
};

export const iterateAllMeshMaterials = (mesh: Mesh, callback: (mesh: Material) => void) => {
    mesh.materials.forEach((material) => callback(material));
    mesh.depthMaterials.forEach((material) => callback(material));
};
